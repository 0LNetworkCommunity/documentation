"use strict";(self.webpackChunkopen_libra_core_docs=self.webpackChunkopen_libra_core_docs||[]).push([[2913],{884:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var t=o(5893),i=o(1151);const r={},s="0L Move Coding Conventions",c={id:"developers/core_devs/move_coding_conventions",title:"0L Move Coding Conventions",description:"For core system code, we observe the following patterns.",source:"@site/docs/developers/core_devs/move_coding_conventions.md",sourceDirName:"developers/core_devs",slug:"/developers/core_devs/move_coding_conventions",permalink:"/developers/core_devs/move_coding_conventions",draft:!1,unlisted:!1,editUrl:"https://github.com/0LNetworkCommunity/documentation/edit/main/docs/developers/core_devs/move_coding_conventions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Governance fixtures",permalink:"/developers/core_devs/governance_fixtures"},next:{title:"smoke_tests",permalink:"/developers/core_devs/smoke_tests"}},a={},l=[{value:"Belt and Suspenders",id:"belt-and-suspenders",level:2},{value:"Denial of Service Precautions",id:"denial-of-service-precautions",level:2},{value:"NOTE: Integer choice",id:"note-integer-choice",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"0l-move-coding-conventions",children:"0L Move Coding Conventions"}),"\n",(0,t.jsx)(n.p,{children:"For core system code, we observe the following patterns."}),"\n",(0,t.jsx)(n.h2,{id:"belt-and-suspenders",children:"Belt and Suspenders"}),"\n",(0,t.jsx)(n.p,{children:'If you see "belt and suspenders" in the code, we are flagging the cases below. It means "yes this appears redundant, but we don\'t trust your fingers".'}),"\n",(0,t.jsx)(n.p,{children:"Move is a new language, and devs won't have developed intuitions about it. Here we are safeguarding against developer errors, not malicious hacks. It's not only for logic bugs, typos, and incomplete work. Some Move language features make it that a fat finger, a git merge, a documentation commit, could expose a public API."}),"\n",(0,t.jsx)(n.p,{children:'For these cases you will see "belt and suspenders" implementations. They will seem inefficient and paranoid. But over time and over many developers, one of these may save from a catastrophic error.'}),"\n",(0,t.jsx)(n.p,{children:'Wherever there are "critical mutations" i.e. state changes related to consensus, accounts values, or privilege escalation, we place multiple redundant checks on functions.'}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Always authorize public functions: This should be obvious. Public functions which call critical mutations are authorized by ",(0,t.jsx)(n.code,{children:"signer"}),"s that are either the account holder or the ",(0,t.jsx)(n.code,{children:"root"})," account."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Friends: Assume a public function with critical mutation must be restricted by a ",(0,t.jsx)(n.code,{children:"friend"})," permission, such that third party modules and scripts can only call through a limit number of paths."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Write the private ",(0,t.jsx)(n.code,{children:"fun"})," first: State mutations for account values, authorization, and consensus critical are done in private functions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Authorize private fun: The private functions which cause mutations also need to be authorized. There are exceptions, but only ones they are deeply nested in other private functions that are authorized. If you accidentally make a private function public, there won't be an issue."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Authorize test helpers: The ",(0,t.jsx)(n.code,{children:"#[test_only]"})," annotations are especially dangerous. If a developer accidentally removes an annotation (or places a line break in the wrong place), then the helper function may be exposed as a public function. Treat test functions as entry points that need to be authorized by ",(0,t.jsx)(n.code,{children:"root"}),". We have seen these errors by the best Move developers, e.g. in Move standard library and vendor code."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Write formal verification ",(0,t.jsx)(n.code,{children:"spec"}),": They don't need to be complicated. Even simple ones will save from a catastrophic deployment. An important pattern is to use them within module code, for example, in ",(0,t.jsx)(n.code,{children:"if"})," flows and ",(0,t.jsx)(n.code,{children:"while"})," loops to check that a condition isn't being met."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"assert!"})," liberally: Functions that only have USER transactions should always abort and return errors for known exceptions. An ",(0,t.jsx)(n.code,{children:"assert!"})," shouldn't prevent you from writing a ",(0,t.jsx)(n.code,{children:"spec"}),", assume you need to do both. Note this does not apply to ",(0,t.jsx)(n.code,{children:"root"})," functions: ",(0,t.jsx)(n.code,{children:"assert!"})," could cause an abort during consensus critical code and that will be fatal. Always use flow control and return early. (There is an exception for genesis of the network in ",(0,t.jsx)(n.code,{children:"genesis.move"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"denial-of-service-precautions",children:"Denial of Service Precautions"}),"\n",(0,t.jsx)(n.h1,{id:"avoid-looping-on-public-calls",children:"Avoid looping on public calls"}),"\n",(0,t.jsxs)(n.p,{children:["There is an easy vector for DoS related to list looping. When users can increment a list at low cost via a public function you've opened a vector for attack. In those cases there is likely another public function which iterates over that list. If there are cheap calls to both functions, then there is an easy DoS attack. With Move there is an even more dangerous vector: ",(0,t.jsx)(n.code,{children:"#[view]"})," functions are free to call via the REST api. So if it loops over a list, you have basically created a free DoS vector."]}),"\n",(0,t.jsx)(n.p,{children:"Where this is unavoidable, a rate-limit needs to be placed on caller which increments the list."}),"\n",(0,t.jsx)(n.p,{children:"V7 TODO: rate limits."}),"\n",(0,t.jsx)(n.h1,{id:"error-codes",children:"Error Codes"}),"\n",(0,t.jsx)(n.p,{children:"The Move compiler does the heavy lifting of mapping .move file error codes to usable Rust messages."}),"\n",(0,t.jsxs)(n.p,{children:["The error code is an integer. And if it is defined by a ",(0,t.jsx)(n.code,{children:"constant"})," with an inline doc comment (",(0,t.jsx)(n.code,{children:"///"}),"), all display errors will include the constant's name and document annotation. See the relevant code in ",(0,t.jsx)(n.code,{children:"proof_of_fee.move"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"  //////// ERRORS /////////\n  /// Not and active validator\n  const ENOT_AN_ACTIVE_VALIDATOR: u64 = 1;\n  /// Bid is above the maximum percentage of the total reward\n  const EBID_ABOVE_MAX_PCT: u64 = 2;\n  /// Retracted your bid too many times\n  const EABOVE_RETRACT_LIMIT: u64 = 3; // Potential update\n"})}),"\n",(0,t.jsx)(n.p,{children:"An error that is correctly defined in .move source, will yield useful descriptions in CLI and API responses."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Error: Unknown error Transaction committed on chain, but failed execution: MoveAbort { location: 0000000000000000000000000000000000000000000000000000000000000001::proof_of_fee, c\node: 131074, info: Some(AbortInfo { reason_name: "EBID_ABOVE_MAX_PCT", description: "Bid is above the maximum percentage of the total reward" }) }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"note-integer-choice",children:"NOTE: Integer choice"}),"\n",(0,t.jsxs)(n.p,{children:["Make sure the error code integer is a low integer. While they are defined as ",(0,t.jsx)(n.code,{children:"u64"})," it shouldn't be above 255 (u8), otherwise the error buffer will overflow, and while it won't create an abort, the error code will not be parsed successfully."]}),"\n",(0,t.jsx)(n.p,{children:"If the error code integer is too high:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"  /// Bid is above the maximum percentage of the total reward\n  const EBID_ABOVE_MAX_PCT: u64 = 20000001;\n"})}),"\n",(0,t.jsx)(n.p,{children:"The mapping will be lost, and you'll get an integer which will not correspond to anything in the source."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Error: Unknown error Transaction committed on chain, but failed execution: MoveAbort { location: 0000000000000000000000000000000000000000000000000000000000000001::proof_of_fee, c\node: 321074, info: None }\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>c,a:()=>s});var t=o(7294);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);