"use strict";(self.webpackChunkopen_libra_core_docs=self.webpackChunkopen_libra_core_docs||[]).push([[6135],{4329:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/node-network-details-b44af8bc4f32f1e51d39b2a0431a62f7.png"},7643:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"guides/node-operators/validators/network-architecture","title":"Network Architecture","description":"There are three types of note in the network. All nodes run the same binary software. The difference between node types is","source":"@site/docs/guides/node-operators/validators/network-architecture.md","sourceDirName":"guides/node-operators/validators","slug":"/guides/node-operators/validators/network-architecture","permalink":"/guides/node-operators/validators/network-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/0LNetworkCommunity/documentation/edit/main/docs/guides/node-operators/validators/network-architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Running a node with docker","permalink":"/guides/node-operators/validators/with-docker-setup"},"next":{"title":"Fullnode YAML file example","permalink":"/guides/node-operators/validators/yaml-templates/fullnode-yaml"}}');var r=n(4848),s=n(8453);const i={},a="Network Architecture",c={},d=[];function l(e){const t={h1:"h1",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"network-architecture",children:"Network Architecture"})}),"\n",(0,r.jsx)(t.p,{children:"There are three types of note in the network. All nodes run the same binary software. The difference between node types is\nby configuration and the arrangement of network connectivity."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Validator Node (VN): A node controlled by an on-chain account that is in the set of currently active validators.\nThe purpose of VNs is to provide chain consensus and to maintain authoratitive chain state.\nValidator nodes communicate with each other to\nmaintain consensus and propagate new transactions. Validator node p2p networking is permissioned: a connection not originating from another validator node\nwill not succeed."}),"\n",(0,r.jsx)(t.li,{children:'Validator Full Node (VFN): A node run in association with a VN, controlled by the same account.\nThe role of the VFN is to provide p2p service to other "downstream" nodes that in turn provide services to users.\nThe purpose of the VFN as a distinct concept from the VN is to act as a\nresource isolation mechanism between the VN and Full Nodes (see below). VFNs receive new chain state from their peer VN and propagate\nthat new chain state "downstream" to FNs. Resource isolation is achieved by only allowing connections\non a non-permissioned p2p network to VNs to come from the peer VFN. Because VNs provide no p2p service except to peer validators,\nthe VFN is the only route by which network state propagates from VNs out to users connected to FNs.'}),"\n",(0,r.jsx)(t.li,{children:"Full Node (FN): A node run by any entity wishing to provide API service. API service is used by end-users e.g. wallet users and commercial services\nsuch as explorers and chain data indexers. Full Nodes may peer with VFNs to receive new chain state, or with other nodes known to the operators.\nFull Nodes are the only providers of API service to any client anywhere in the network."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["The diagram below illustrates the arrangement of node types showing their network configuration:\n",(0,r.jsx)(t.img,{alt:"Network Diagram",src:n(4329).A+"",title:"Network Diagram",width:"1500",height:"1100"})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(6540);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);